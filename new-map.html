<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Supply Chain Map</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #f5f5f5; }
        
        .map-container {
            width: 100%;
            max-width: 1200px;
            height: 600px;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            background: white;
        }
        
        #map { 
            width: 100%; 
            height: 100%; 
            background: white; 
        }
        
        .mapboxgl-popup-content {
            padding: 0;
            border-radius: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            min-width: 280px;
            max-width: 320px;
        }
        
        .stage-header {
            border-bottom: 1px solid #f0f2f5;
            padding-bottom: 16px;
            margin-bottom: 16px;
        }
        
        .stage-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0 0 6px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stage-location {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
        }
        
        .supplier-section {
            margin-bottom: 12px;
        }
        
        .supplier-label {
            font-size: 12px;
            font-weight: 600;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .supplier-name {
            font-size: 15px;
            font-weight: 500;
            color: #374151;
            margin: 0;
        }

        .detail-section {
            margin-bottom: 8px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 600;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }

        .detail-value {
            font-size: 14px;
            color: #374151;
            margin: 0;
        }

        .stage-popup {
            padding: 20px;
        }

        .phase-section {
            border-bottom: 1px solid #f0f2f5;
            padding-bottom: 16px;
            margin-bottom: 16px;
        }

        .phase-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0 0 4px 0;
        }

        .sub-phase-title {
            font-size: 14px;
            color: #6b7280;
            margin: 0 0 16px 0;
        }

        .stage-badge {
            display: inline-block;
            background: #000000;
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .location-section {
            margin-top: 16px;
        }

        .location-value {
            font-size: 15px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0;
        }

        .mapboxgl-ctrl-attrib,
        .mapboxgl-ctrl-bottom-right,
        .mapboxgl-ctrl-bottom-left {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="map-container">
        <div id='map'></div>
    </div>
   
    <script>
        // Replace with your actual Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiZmFyaWRpbyIsImEiOiJjbWVrNGFrdTIwMmNpMnFwa3NnaGIxMzZkIn0.Zfis6EEHZpQxhx5c3M-qWg';

        // Updated supply chain data with city information
        const supplyChainData = [
            {
                id: 2322,
                supplier: "No name",
                country: "AU",
                city: "Griffith",
                source: [-31.25321830, 146.92109900],
                destination: [35.2989, 135.259],
                parent_supplier: "Ayabe spinning co ltd.",
                parent_location: "JP",
                parent_city: "Kyoto",
                stage: "Raw materials",
                level: 1,
                phase: "Primary Harvest / Sourcing",
                sub_phase: "Cotton farming",
                phase_description: "Cultivation and harvesting of cotton plants to obtain raw fibers."
            },
            {
                id: 2321,
                supplier: "Ayabe spinning co ltd.",
                country: "JP",
                city: "Kyoto",
                source: [35.2989, 135.259],
                destination: [35.02107, 135.75385],
                parent_supplier: "Kuroki",
                parent_location: "JP",
                parent_city: "Okayama",
                stage: "Yarn",
                level: 2,
                phase: "Thread Production",
                sub_phase: "Spinning",
                phase_description: "Transforming raw fibers into continuous yarn."
            },
            {
                id: 2319,
                supplier: "Kuroki",
                country: "JP",
                city: "Okayama",
                source: [35.02107, 135.75385],
                destination: [35.01161, 136.96396],
                parent_supplier: "Toukai Senko co ltd",
                parent_location: "JP",
                parent_city: "Nagoya",
                stage: "Fabric process",
                level: 3,
                phase: "Forming Fabric",
                sub_phase: "Weaving",
                phase_description: "Interlacing yarns to produce woven fabrics"
            },
            {
                id: 2320,
                supplier: "TOUKAI SENKO CO.,LTD.",
                country: "JP",
                city: "Nagoya",
                source: [35.01161, 136.96396],
                destination: [41.4444, -8.2962],
                parent_supplier: "Lisama",
                parent_location: "PT",
                parent_city: "Guimaraes",
                stage: "Fabric process",
                level: 3,
                phase: "Dyeing & Finishing",
                sub_phase: "Dyeing",
                phase_description: "Coloring yarns or fabrics using dyes or pigments"
            },
            {
                id: 2324,
                supplier: "Nilorn",
                country: "SE",
                city: "Borås",
                source: [57.721035, 12.939819],
                destination: [41.4444, -8.2962],
                parent_supplier: "Lisama",
                parent_location: "PT",
                parent_city: "Guimaraes",
                stage: "Fabric process",
                level: 3,
                phase: "Label production",
                sub_phase: "Label production",
                phase_description: "Manufacturing woven, printed, or embroidered labels that provide brand identity and care instructions for garments."
            },
            {
                id: 2323,
                supplier: "Crafil",
                country: "PT",
                city: "Oliveira Sao Mateus",
                source: [41.39136, -8.40363],
                destination: [41.4444, -8.2962],
                parent_supplier: "Lisama",
                parent_location: "PT",
                parent_city: "Guimaraes",
                stage: "Assembly",
                level: 4,
                phase: "Assembly",
                sub_phase: "Thread winding",
                phase_description: "Winding dyed or raw thread onto spools, cones, or bobbins, preparing it for sewing and garment assembly."
            },
            {
                id: 2316,
                supplier: "Lisama",
                country: "PT",
                city: "Guimaraes",
                source: [41.4444, -8.2962],
                destination: [41.4123881, -8.5206366],
                parent_supplier: "IVN",
                parent_location: "PT",
                parent_city: "Irmãos Vila Nova",
                stage: "Assembly",
                level: 4,
                phase: "Assembly",
                sub_phase: "Cut & Sew",
                phase_description: "Cutting and stitching panels and components together into garments."
            },
            {
                id: 2317,
                supplier: "IVN",
                country: "PT",
                city: "Irmãos Vila Nova",
                source: [41.4123881, -8.5206366],
                destination: [40.9692, -8.1513],
                parent_supplier: "Pontipromenor",
                parent_location: "PT",
                parent_city: "Alvarenga",
                stage: "Assembly",
                level: 4,
                phase: "Laundry & Dye House",
                sub_phase: "Laundry",
                phase_description: "Industrial washing of garments after assembly to achieve the desired hand-feel, fit, and appearance"
            },
            {
                id: 2318,
                supplier: "Pontipormenor",
                country: "PT",
                city: "Alvarenga",
                source: [40.9692, -8.1513],
                destination: [59.9290137, 10.8200294],
                parent_supplier: "Livid",
                parent_location: "NO",
                parent_city: "Oslo",
                stage: "Assembly",
                level: 4,
                phase: "Package & Finishing",
                sub_phase: "Package & finishing",
                phase_description: "Final stage of garment preparation where items are pressed, tagged, folded, and packaged for distribution"
            },
            {
                id: 2325,
                supplier: "Livid",
                country: "NO",
                city: "Oslo",
                source: [59.9290137, 10.8200294],
                destination: null,
                parent_supplier: null,
                parent_location: null,
                parent_city: null,
                stage: "Warehouse",
                level: 5,
                phase: "Warehousing",
                sub_phase: "Product storing",
                phase_description: "Product is stored at our central warehouse in Oslo"
            }
        ];

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [20, 45],
            zoom: 3
        });

        // Track current popup to prevent multiple popups
        let currentPopup = null;

        map.on('load', async () => {
            // Remove text labels
            const layers = map.getStyle().layers;
            layers.forEach((layer) => {
                if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
                    map.removeLayer(layer.id);
                }
            });

            // Function to get maritime route using SeaRoute API
            async function getMaritimeRoute(start, end) {
                try {
                    const response = await fetch(`https://api.searoute.org/route/v1/?origin=${start[1]},${start[0]}&destination=${end[1]},${end[0]}&units=km`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.features && data.features[0] && data.features[0].geometry) {
                            return data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                        }
                    }
                } catch (error) {
                    console.log('SeaRoute API failed, trying alternative...');
                }

                return createMaritimeApproximation(start, end);
            }

            // Function to create accurate maritime routes that follow coastlines and water bodies
            function createMaritimeApproximation(start, end) {
                const [startLat, startLng] = start;
                const [endLat, endLng] = end;
                
                const maritimeWaypoints = {
                    suezNorth: [31.25, 32.3],
                    suezSouth: [29.97, 32.5],
                    gibraltarEast: [35.9, -5.3],
                    gibraltarWest: [36.0, -5.8],
                    singaporeStrait: [1.2, 103.9],
                    malaccaStrait: [4.0, 100.0],
                    doverStrait: [51.0, 1.4],
                    mumbai: [19.0, 72.8],
                    dubai: [25.2, 55.3],
                    piraeus: [37.9, 23.7],
                    valencia: [39.5, -0.4],
                    rotterdam: [51.9, 4.1],
                    hamburg: [53.5, 10.0],
                    redSeaExit: [12.6, 43.3],
                    arabianSeaWest: [20.0, 58.0],
                    bayOfBiscay: [45.0, -5.0],
                    northSeaEntry: [55.0, 2.0],
                    baltricEntry: [57.0, 10.0],
                    pacificMid: [10.0, 140.0],
                    indianOceanWest: [5.0, 70.0],
                    atlanticEast: [40.0, -15.0],
                    mediterraneanCenter: [36.0, 15.0],
                };

                let waypoints = [start];

                if (startLng > 140 && startLat < -20 && endLng > 130 && endLat > 30) {
                    waypoints.push([startLat, 155]);
                    waypoints.push([0, 155]);
                    waypoints.push([20, 145]);
                    waypoints.push([30, 140]);
                } else if (startLng > 130 && startLat > 30 && endLng < 0 && endLat > 35) {
                    waypoints.push([30, 125]);
                    waypoints.push([15, 120]);
                    waypoints.push(maritimeWaypoints.singaporeStrait);
                    waypoints.push(maritimeWaypoints.malaccaStrait);
                    waypoints.push([6, 95]);
                    waypoints.push(maritimeWaypoints.indianOceanWest);
                    waypoints.push(maritimeWaypoints.arabianSeaWest);
                    waypoints.push(maritimeWaypoints.redSeaExit);
                    waypoints.push([20, 40]);
                    waypoints.push(maritimeWaypoints.suezSouth);
                    waypoints.push(maritimeWaypoints.suezNorth);
                    waypoints.push(maritimeWaypoints.mediterraneanCenter);
                    waypoints.push([35, 5]);
                    waypoints.push(maritimeWaypoints.gibraltarEast);
                    waypoints.push(maritimeWaypoints.gibraltarWest);
                    waypoints.push(maritimeWaypoints.atlanticEast);
                    waypoints.push([42, -10]);
                } else if (startLng > 10 && startLat > 55 && endLng < 0 && endLat > 35) {
                    waypoints.push([56, 12]);
                    waypoints.push([57, 8]);
                    waypoints.push([58, 4]);
                    waypoints.push(maritimeWaypoints.doverStrait);
                    waypoints.push([49, -2]);
                    waypoints.push(maritimeWaypoints.bayOfBiscay);
                    waypoints.push([43, -9]);
                } else if (startLng < 0 && startLat > 35 && endLng > 5 && endLat > 55) {
                    waypoints.push([42, -12]);
                    waypoints.push([45, -10]);
                    waypoints.push(maritimeWaypoints.bayOfBiscay);
                    waypoints.push([50, -5]);
                    waypoints.push(maritimeWaypoints.doverStrait);
                    waypoints.push(maritimeWaypoints.northSeaEntry);
                    waypoints.push([58, 8]);
                } else if (Math.abs(startLng - endLng) < 15 && Math.abs(startLat - endLat) < 15) {
                    const midLat = (startLat + endLat) / 2;
                    const midLng = (startLng + endLng) / 2;
                    
                    if (startLng < 0 || endLng < 0) {
                        waypoints.push([midLat, Math.min(startLng, endLng) - 1]);
                    } else {
                        waypoints.push([midLat + 1, midLng]);
                    }
                }

                waypoints.push(end);
                return waypoints;
            }

            // Function to check if route is international
            function isInternationalRoute(sourceCountry, destCountry) {
                return sourceCountry !== destCountry;
            }

            // Function to create arrows aligned with line segments
            function createArrowsAlongRoute(coordinates, arrowSpacing = 2.0) {
                const arrows = [];
                
                if (coordinates.length < 2) return arrows;
                
                // Calculate total route length
                let totalLength = 0;
                const segmentLengths = [];
                
                for (let i = 0; i < coordinates.length - 1; i++) {
                    const start = coordinates[i];
                    const end = coordinates[i + 1];
                    const segmentLength = Math.sqrt(
                        Math.pow(end[0] - start[0], 2) + Math.pow(end[1] - start[1], 2)
                    );
                    segmentLengths.push(segmentLength);
                    totalLength += segmentLength;
                }
                
                // Create arrows at regular intervals
                const numArrows = Math.floor(totalLength / arrowSpacing);
                
                for (let arrowIndex = 1; arrowIndex < numArrows; arrowIndex++) {
                    const targetDistance = (arrowIndex / numArrows) * totalLength;
                    
                    // Find position along route
                    let accumulatedDistance = 0;
                    let segmentIndex = 0;
                    let segmentProgress = 0;
                    
                    for (let i = 0; i < segmentLengths.length; i++) {
                        if (accumulatedDistance + segmentLengths[i] >= targetDistance) {
                            segmentIndex = i;
                            segmentProgress = (targetDistance - accumulatedDistance) / segmentLengths[i];
                            break;
                        }
                        accumulatedDistance += segmentLengths[i];
                    }
                    
                    // Get the specific segment the arrow is on
                    const segmentStart = coordinates[segmentIndex];
                    const segmentEnd = coordinates[segmentIndex + 1] || segmentStart;
                    
                    // Calculate arrow position
                    const arrowLng = segmentStart[0] + (segmentEnd[0] - segmentStart[0]) * segmentProgress;
                    const arrowLat = segmentStart[1] + (segmentEnd[1] - segmentStart[1]) * segmentProgress;
                    
                    // Calculate bearing for THIS specific segment (so arrow aligns with line)
                    const segmentDeltaX = segmentEnd[0] - segmentStart[0];
                    const segmentDeltaY = segmentEnd[1] - segmentStart[1];
                    const segmentBearing = Math.atan2(segmentDeltaX, segmentDeltaY) * (180 / Math.PI) + 90;
                    
                    arrows.push({
                        coordinates: [arrowLng, arrowLat],
                        bearing: segmentBearing
                    });
                }
                
                return arrows;
            }

            // Create arrow SVG - larger and more distinct
            const arrowSVG = `
                <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 10 L10 3 L10 7 L17 7 L17 13 L10 13 L10 17 Z" fill="#000000" stroke="#ffffff" stroke-width="1"/>
                </svg>
            `;

            const arrowDataURL = 'data:image/svg+xml;base64,' + btoa(arrowSVG);

            // Load arrow image and create routes
            const arrowImg = new Image();
            arrowImg.onload = () => {
                map.addImage('direction-arrow', arrowImg);
                createRoutesWithArrows();
            };
            arrowImg.onerror = () => {
                console.error('Error loading arrow, creating routes without arrows');
                createRoutesWithArrows();
            };
            arrowImg.src = arrowDataURL;

            async function createRoutesWithArrows() {
                for (const item of supplyChainData) {
                    if (item.destination) {
                        let routeCoordinates;
                        const isInternational = isInternationalRoute(item.country, item.parent_location);
                        
                        if (isInternational) {
                            console.log(`Getting maritime route from ${item.country} to ${item.parent_location}`);
                            const routePoints = await getMaritimeRoute(item.source, item.destination);
                            routeCoordinates = routePoints.map(point => [point[1], point[0]]);
                        } else {
                            routeCoordinates = [
                                [item.source[1], item.source[0]],
                                [item.destination[1], item.destination[0]]
                            ];
                        }

                        // Add route line (solid for domestic, dashed for international)
                        map.addSource(`route-${item.id}`, {
                            'type': 'geojson',
                            'data': {
                                'type': 'Feature',
                                'properties': {
                                    'stage': item.stage,
                                    'supplier': item.supplier,
                                    'level': item.level,
                                    'isInternational': isInternational,
                                    'routeId': item.id
                                },
                                'geometry': {
                                    'type': 'LineString',
                                    'coordinates': routeCoordinates
                                }
                            }
                        });

                        // Add line layer
                        map.addLayer({
                            'id': `route-${item.id}`,
                            'type': 'line',
                            'source': `route-${item.id}`,
                            'layout': {
                                'line-join': 'round',
                                'line-cap': 'round'
                            },
                            'paint': {
                                'line-color': '#000000',
                                'line-width': [
                                    'interpolate',
                                    ['linear'],
                                    ['zoom'],
                                    1, isInternational ? 1.5 : 2,
                                    6, isInternational ? 2 : 3,
                                    12, isInternational ? 3 : 4
                                ],
                                'line-opacity': isInternational ? 0.8:0.2,
                                'line-dasharray': isInternational ? [2, 2] : [1, 0] // Dashed for international, solid for domestic
                            }
                        });

                        // Create arrows along the route (much fewer arrows)
                        const arrows = createArrowsAlongRoute(routeCoordinates, isInternational ? 12 : 9.0);
                        
                        if (arrows.length > 0) {
                            const arrowFeatures = arrows.map((arrow, index) => ({
                                'type': 'Feature',
                                'properties': {
                                    'bearing': arrow.bearing,
                                    'routeId': item.id,
                                    'isInternational': isInternational
                                },
                                'geometry': {
                                    'type': 'Point',
                                    'coordinates': arrow.coordinates
                                }
                            }));

                            map.addSource(`route-arrows-${item.id}`, {
                                'type': 'geojson',
                                'data': {
                                    'type': 'FeatureCollection',
                                    'features': arrowFeatures
                                }
                            });

                            map.addLayer({
                                'id': `route-arrows-${item.id}`,
                                'type': 'symbol',
                                'source': `route-arrows-${item.id}`,
                                'layout': {
                                    'icon-image': 'direction-arrow',
                                    'icon-size': [
                                        'interpolate',
                                        ['linear'],
                                        ['zoom'],
                                        1, 0.8,   // Increased from 0.6
                                        6, 1.3,   // Increased from 1.0
                                        12, 2.0   // Increased from 1.5
                                    ],
                                    'icon-rotate': ['get', 'bearing'],
                                    'icon-rotation-alignment': 'map',
                                    'icon-allow-overlap': true,
                                    'icon-ignore-placement': true
                                }
                            });
                        }
                    }
                }

                // Add supplier points after routes are created
                addSupplierPoints();
            }

            function addSupplierPoints() {
                // Add source points
                map.addSource('source-points', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': supplyChainData.map(item => ({
                            'type': 'Feature',
                            'properties': {
                                'supplier': item.supplier,
                                'stage': item.stage,
                                'level': item.level,
                                'country': item.country,
                                'city':item.city,
                                'phase': item.phase,
                                'sub_phase': item.sub_phase || 'N/A',
                                'coordinates': `${item.source[0].toFixed(4)}, ${item.source[1].toFixed(4)}`,
                                'type': 'source'
                            },
                            'geometry': {
                                'type': 'Point',
                                'coordinates': [item.source[1], item.source[0]]
                            }
                        }))
                    }
                });

                // Add destination points
                const destinationFeatures = supplyChainData
                    .filter(item => item.destination && item.parent_supplier)
                    .map(item => ({
                        'type': 'Feature',
                        'properties': {
                            'supplier': item.parent_supplier,
                            'country': item.parent_location,
                            'city':item.city,
                            'phase': item.phase,
                            'sub_phase': item.sub_phase || 'N/A',
                            'coordinates': `${item.destination[0].toFixed(4)}, ${item.destination[1].toFixed(4)}`,
                            'type': 'destination'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [item.destination[1], item.destination[0]]
                        }
                    }));

                map.addSource('destination-points', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': destinationFeatures
                    }
                });

                // Create custom pin SVG
                const pinSVG = `
                   <svg fill="#000000" height="8px" width="8px" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 21.041 21.041" xml:space="preserve"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g id="c88_square"> <path d="M20.51,0H0.524C0.267,0,0.056,0.209,0.056,0.469v20.104c0,0.255,0.211,0.468,0.468,0.468H20.51 c0.263,0,0.476-0.213,0.476-0.468V0.469C20.986,0.209,20.772,0,20.51,0z"></path> </g> <g id="Capa_1_233_"> </g> </g> </g></svg>
                `;

                const pinDataURL = 'data:image/svg+xml;base64,' + btoa(pinSVG);

                // Load the custom pin image
                const img = new Image();
                img.onload = () => {
                    map.addImage('custom-pin', img);
                    
                    map.addLayer({
                        'id': 'source-points',
                        'type': 'symbol',
                        'source': 'source-points',
                        'layout': {
                            'icon-image': 'custom-pin',
                            'icon-size': 1.2,
                            'icon-anchor': 'bottom',
                            'icon-allow-overlap': true,
                            'icon-ignore-placement': true
                        }
                    });

                    map.addLayer({
                        'id': 'destination-points',
                        'type': 'symbol',
                        'source': 'destination-points',
                        'layout': {
                            'icon-image': 'custom-pin',
                            'icon-size': 0.8,
                            'icon-anchor': 'bottom',
                            'icon-allow-overlap': true,
                            'icon-ignore-placement': true
                        }
                    });

                    setupEventHandlers();
                };
                
                img.onerror = () => {
                    console.error('Error loading custom pin, falling back to circles');
                    addCircleLayers();
                };
                
                img.src = pinDataURL;

                function addCircleLayers() {
                    map.addLayer({
                        'id': 'source-points',
                        'type': 'circle',
                        'source': 'source-points',
                        'paint': {
                            'circle-radius': 6,
                            'circle-color': '#000000',
                            'circle-opacity': 1,
                            'circle-stroke-width': 0
                        }
                    });

                    map.addLayer({
                        'id': 'destination-points',
                        'type': 'circle',
                        'source': 'destination-points',
                        'paint': {
                            'circle-radius': 4,
                            'circle-color': '#000000',
                            'circle-opacity': 1,
                            'circle-stroke-width': 0
                        }
                    });

                    setupEventHandlers();
                }
            }

            function setupEventHandlers() {
                // Function to close current popup and create new one
                function showPopup(lngLat, content) {
                    if (currentPopup) {
                        currentPopup.remove();
                    }
                    
                    currentPopup = new mapboxgl.Popup({
                        offset: 25,
                        closeButton: true,
                        closeOnClick: false
                    })
                        .setLngLat(lngLat)
                        .setHTML(content)
                        .addTo(map);

                    currentPopup.on('close', () => {
                        currentPopup = null;
                    });
                }

                // <div class="phase-title">${properties.phase}</div>
                                // <p class="sub-phase-title">${properties.sub_phase}</p>
                                // <div class="stage-badge">${properties.level}: ${properties.stage}</div>
                // Add click events for popups
                map.on('click', 'source-points', (e) => {
                    const properties = e.features[0].properties;
                    const popupContent = `
                        <div class="stage-popup">
                            <div class="phase-section">
                                <div class="phase-title">${properties.supplier}</div>
                                 <div class="stage-badge">${properties.level}: ${properties.stage}</div>
                            </div>
                            <div class="supplier-section">
                                <div class="supplier-label">Phase</div>
                                <p class="location-value">${properties.phase}</p>
                                <p class="sub-phase-title">${properties.sub_phase}</p>
                            </div>
                            <div class="location-section">
                                <div class="detail-label">Location</div>
                                <p class="location-value">${properties.city}, ${properties.country}</p>
                            </div>
                        </div>
                    `;
                    
                    showPopup(e.lngLat, popupContent);
                });

                map.on('click', 'destination-points', (e) => {
                    const properties = e.features[0].properties;
                    const popupContent = `
                        <div class="stage-popup">
                            <div class="phase-section">
                                <div class="phase-title">${properties.supplier}</div>
                                <div class="stage-badge"> ${properties.stage ? properties.stage :'Destination'} </div>
                            </div>
                            <div class="supplier-section">
                                <div class="supplier-label">Phase</div>
                                <p class="location-value">${properties.phase}</p>
                                <p class="sub-phase-title">${properties.sub_phase}</p>
                            </div>
                            
                            <div class="location-section">
                                <div class="detail-label">Location</div>
                                <p class="location-value">${properties.city}, ${properties.country}</p>
                            </div>
                        </div>
                    `;
                    
                    showPopup(e.lngLat, popupContent);
                });

                // Change cursor on hover
                map.on('mouseenter', 'source-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'source-points', () => {
                    map.getCanvas().style.cursor = '';
                });
                map.on('mouseenter', 'destination-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'destination-points', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Fit map to show all points
                const allCoordinates = [];
                supplyChainData.forEach(item => {
                    allCoordinates.push([item.source[1], item.source[0]]);
                    if (item.destination) {
                        allCoordinates.push([item.destination[1], item.destination[0]]);
                    }
                });

                const bounds = new mapboxgl.LngLatBounds();
                allCoordinates.forEach(coord => bounds.extend(coord));
                map.fitBounds(bounds, { padding: 50 });
            }
        });
        
        // Add error handling
        map.on('error', (e) => {
            console.error('Mapbox error:', e);
            document.getElementById('map').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: white; font-family: Arial, sans-serif; text-align: center; padding: 20px;">
                    <div>
                        <h2>Map Failed to Load</h2>
                        <p>Please ensure you have a valid Mapbox access token.</p>
                    </div>
                </div>
            `;
        });
    </script>
</body>
</html>